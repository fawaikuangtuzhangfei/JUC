1.对volatile的理解
	volatile可以1.禁止指令重排 2.保证可见性 但是不能保证原子性
2.JMM理解
	JMM是Java内存模型的简称，本身是抽象的概念，JMM规定所有的变量必须存在主内存中，
	所有线程都可以访问，但是线程想要进行操作的话只能将主内存中的变量拷贝一份到自己
	的工作空间中，如何对变量进行操作，操作完成后写回入主内存中。也就是说线程直接是
	相互隔离的，是通过主内存来进行通讯的。
可见性：
	可见性简单来说就是共享变量修改后立马写回主内存，并且其他线程可以立马得知，否则就
	会造成问题，比如线程a修改后还没来得及写入，b线程同时进行了修改且写入了，此刻a得到
	cpu后写入，这样就把b的覆盖掉了，这种工作内存和主内存同步延迟的就是可见性问题。
原子性：以number++来说
	number++有3步操作 1.获取number的值 2.将number值加1 3.将number写回入内存
	这样的话 就可能存在问题
有序性：
	计算机在执行程序时，为了提高性能，编译器和处理器通常会做一些指令重排
	1.编译器优化的重排 2.指令并行的重排 3.内存系统的重排
	同时在进行重排的时候会注意数据之间的依赖性；在多线程的环境下，指令重排会出现问题

volatile会加一个内存屏障，这个内存屏障有两个作用，1.禁止前后的指令重排(有序性)
2.强制刷新cpu的缓存数据，使各个线程都能读取到数据的最新版本(可见性)


	